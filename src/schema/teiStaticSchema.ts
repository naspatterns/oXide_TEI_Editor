import type { ElementSpec, AttrSpec } from '../types/schema';
import { TEI_AUTO_GENERATED_ELEMENTS } from './teiAutoGenerated';

/**
 * Static TEI schema data for immediate autocompletion.
 * This covers the most commonly used TEI elements and attributes,
 * derived from the TEI Lite and TEI All guidelines.
 *
 * This serves as a fast fallback when full RNG parsing isn't available,
 * and as the base for the "TEI Lite" schema preset.
 */

const globalAttrs: AttrSpec[] = [
  { name: 'xml:id', documentation: 'Unique identifier' },
  { name: 'xml:lang', documentation: 'Language code (e.g. "en", "ko")' },
  { name: 'n', documentation: 'Number or label' },
  { name: 'type', documentation: 'Type classification' },
  { name: 'subtype', documentation: 'Sub-classification' },
  { name: 'rend', documentation: 'Rendition (e.g. "italic", "bold")' },
  { name: 'rendition', documentation: 'Points to a rendition element' },
  { name: 'style', documentation: 'CSS-like style string' },
  { name: 'resp', documentation: 'Responsible party' },
  { name: 'cert', documentation: 'Certainty level', values: ['high', 'medium', 'low', 'unknown'] },
  { name: 'source', documentation: 'Source of information' },
  { name: 'corresp', documentation: 'Corresponds to' },
  { name: 'ana', documentation: 'Analysis or interpretation' },
];

function el(
  name: string,
  doc: string,
  children: string[],
  extraAttrs: AttrSpec[] = [],
): ElementSpec {
  return {
    name,
    documentation: doc,
    children,
    attributes: [...globalAttrs, ...extraAttrs],
  };
}

// Header elements
const headerChildren = ['fileDesc', 'encodingDesc', 'profileDesc', 'revisionDesc', 'xenoData'];
const fileDescChildren = ['titleStmt', 'editionStmt', 'extent', 'publicationStmt', 'seriesStmt', 'notesStmt', 'sourceDesc'];
const titleStmtChildren = ['title', 'author', 'editor', 'funder', 'principal', 'sponsor', 'respStmt'];

// Text structure
const divLikeChildren = ['head', 'p', 'ab', 'div', 'lg', 'l', 'sp', 's', 'list', 'table', 'figure', 'note', 'quote', 'cit', 'bibl', 'milestone', 'pb', 'lb', 'cb', 'gap', 'space', 'fw', 'trailer', 'closer', 'opener', 'salute', 'signed', 'dateline', 'byline', 'argument', 'epigraph', 'floatingText', 'entry'];

const paraContent = ['hi', 'emph', 'title', 'name', 'persName', 'placeName', 'orgName', 'date', 'num', 'measure', 'rs', 'ref', 'ptr', 'note', 'q', 'quote', 'cit', 'bibl', 'foreign', 'term', 'gloss', 'soCalled', 'mentioned', 'abbr', 'expan', 'choice', 'orig', 'reg', 'sic', 'corr', 'add', 'del', 'subst', 'supplied', 'unclear', 'gap', 'pb', 'lb', 'cb', 'milestone', 'seg', 'anchor', 'fw', 'app', 'witDetail', 'figure', 'graphic', 'formula', 'list', 'table', 's', 'w', 'c', 'pc', 'cl', 'phr'];

export const TEI_LITE_ELEMENTS: ElementSpec[] = [
  // Root
  el('TEI', 'Root element of a TEI document', ['teiHeader', 'text', 'facsimile', 'standOff']),

  // Header
  el('teiHeader', 'TEI header containing metadata', headerChildren),
  el('fileDesc', 'File description', fileDescChildren),
  el('titleStmt', 'Title statement', titleStmtChildren),
  el('title', 'Title of the work', paraContent, [
    { name: 'level', values: ['a', 'm', 's', 'j', 'u'], documentation: 'Bibliographic level' },
  ]),
  el('author', 'Author of the work', paraContent),
  el('editor', 'Editor of the work', paraContent, [
    { name: 'role', documentation: 'Role of the editor' },
  ]),
  el('respStmt', 'Responsibility statement', ['resp', 'name', 'persName', 'orgName']),
  el('resp', 'Nature of responsibility', paraContent),
  el('publicationStmt', 'Publication statement', ['publisher', 'distributor', 'authority', 'pubPlace', 'address', 'date', 'idno', 'availability', 'p']),
  el('publisher', 'Publisher name', paraContent),
  el('pubPlace', 'Publication place', paraContent),
  el('availability', 'Availability statement', ['p', 'licence'], [
    { name: 'status', values: ['free', 'unknown', 'restricted'], documentation: 'Availability status' },
  ]),
  el('licence', 'Licence information', ['p'], [
    { name: 'target', documentation: 'URL of the licence' },
  ]),
  el('sourceDesc', 'Source description', ['p', 'bibl', 'biblStruct', 'biblFull', 'listBibl', 'msDesc', 'listWit']),
  el('encodingDesc', 'Encoding description', ['projectDesc', 'editorialDecl', 'tagsDecl', 'classDecl', 'appInfo', 'p']),
  el('profileDesc', 'Profile description', ['creation', 'langUsage', 'textClass', 'correspDesc', 'settingDesc', 'particDesc', 'abstract']),
  el('revisionDesc', 'Revision description', ['change', 'listChange']),
  el('change', 'A change record', paraContent, [
    { name: 'when', documentation: 'Date of change' },
    { name: 'who', documentation: 'Person responsible' },
  ]),
  el('idno', 'Identifier', paraContent, [
    { name: 'type', documentation: 'Type of identifier (e.g. ISBN, DOI, URL)' },
  ]),

  // Text structure
  el('text', 'Text body container', ['front', 'body', 'back', 'group']),
  el('front', 'Front matter', ['titlePage', ...divLikeChildren]),
  el('body', 'Document body', divLikeChildren),
  el('back', 'Back matter', divLikeChildren),
  el('group', 'Group of texts', ['text', 'group']),
  el('div', 'Text division', divLikeChildren, [
    { name: 'type', documentation: 'Type (e.g. chapter, section, act, scene)' },
  ]),
  el('head', 'Heading', paraContent),
  el('p', 'Paragraph', paraContent),
  el('ab', 'Anonymous block', paraContent),
  el('trailer', 'Closing formula at end of division', paraContent),
  el('closer', 'Closing group (e.g. at end of letter)', ['salute', 'signed', 'dateline', 'p', ...paraContent]),
  el('opener', 'Opening group (e.g. at start of letter)', ['salute', 'signed', 'dateline', 'p', ...paraContent]),
  el('salute', 'Salutation', paraContent),
  el('signed', 'Signature', paraContent),
  el('dateline', 'Dateline', paraContent),

  // Poetry
  el('lg', 'Line group (stanza)', ['l', 'lg', 'head', 'trailer', 'pb', 'lb'], [
    { name: 'type', documentation: 'Type (e.g. stanza, couplet, tercet)' },
    { name: 'rhyme', documentation: 'Rhyme scheme' },
    { name: 'met', documentation: 'Metre' },
  ]),
  el('l', 'Verse line', paraContent, [
    { name: 'met', documentation: 'Metre' },
    { name: 'rhyme', documentation: 'Rhyme label' },
    { name: 'part', values: ['I', 'M', 'F', 'N', 'Y'], documentation: 'Part of metrical line' },
  ]),

  // Drama
  el('sp', 'Speech', ['speaker', 'p', 'lg', 'l', 'ab', 'stage', 'note'], [
    { name: 'who', documentation: 'Speaker identifier' },
  ]),
  el('speaker', 'Speaker name', paraContent),
  el('stage', 'Stage direction', paraContent, [
    { name: 'type', documentation: 'Type (e.g. entrance, exit, setting, delivery, business)' },
  ]),
  el('castList', 'Cast list', ['castItem', 'castGroup', 'head']),
  el('castItem', 'Cast list item', ['role', 'roleDesc', 'actor']),
  el('role', 'Role name', paraContent),
  el('roleDesc', 'Role description', paraContent),

  // Highlighting & emphasis
  el('hi', 'Highlighted text', paraContent, [
    { name: 'rend', documentation: 'Rendition (e.g. italic, bold, sup, sub)' },
  ]),
  el('emph', 'Emphasized text', paraContent),

  // Names & entities
  el('name', 'Name', paraContent, [
    { name: 'type', documentation: 'Type (e.g. person, place, org)' },
    { name: 'ref', documentation: 'Reference to authority record' },
  ]),
  el('persName', 'Personal name', [...paraContent, 'forename', 'surname', 'genName', 'roleName', 'addName', 'nameLink'], [
    { name: 'ref', documentation: 'Reference to person record' },
  ]),
  el('forename', 'Forename', paraContent),
  el('surname', 'Surname', paraContent),
  el('placeName', 'Place name', [...paraContent, 'settlement', 'region', 'country', 'bloc', 'geogName'], [
    { name: 'ref', documentation: 'Reference to place record' },
  ]),
  el('settlement', 'Settlement name', paraContent),
  el('region', 'Region name', paraContent),
  el('country', 'Country name', paraContent),
  el('orgName', 'Organization name', paraContent, [
    { name: 'ref', documentation: 'Reference to org record' },
  ]),
  el('rs', 'Referring string', paraContent, [
    { name: 'type', documentation: 'Type of referent' },
    { name: 'ref', documentation: 'Reference' },
    { name: 'key', documentation: 'Key for referent' },
  ]),

  // Dates & numbers
  el('date', 'Date', paraContent, [
    { name: 'when', documentation: 'Normalized date (ISO 8601)' },
    { name: 'notBefore', documentation: 'Earliest possible date' },
    { name: 'notAfter', documentation: 'Latest possible date' },
    { name: 'from', documentation: 'Start of date range' },
    { name: 'to', documentation: 'End of date range' },
    { name: 'calendar', documentation: 'Calendar system' },
  ]),
  el('num', 'Number', paraContent, [
    { name: 'value', documentation: 'Numeric value' },
    { name: 'type', documentation: 'Type (cardinal, ordinal, fraction, percentage)' },
  ]),
  el('measure', 'Measurement', paraContent, [
    { name: 'quantity', documentation: 'Numeric quantity' },
    { name: 'unit', documentation: 'Unit of measurement' },
    { name: 'commodity', documentation: 'Commodity being measured' },
  ]),

  // Quotation & citation
  el('q', 'Quoted text', paraContent, [
    { name: 'who', documentation: 'Speaker' },
    { name: 'type', documentation: 'Type (spoken, written, thought)' },
  ]),
  el('quote', 'Block quotation', [...paraContent, 'p', 'lg', 'l']),
  el('cit', 'Citation (quote + reference)', ['quote', 'bibl', 'ref', 'q']),
  el('bibl', 'Bibliographic reference', [...paraContent, 'author', 'editor', 'title', 'date', 'publisher', 'pubPlace', 'idno']),

  // Terms & glosses
  el('foreign', 'Foreign word', paraContent, [
    { name: 'xml:lang', documentation: 'Language of the foreign text' },
  ]),
  el('term', 'Technical term', paraContent, [
    { name: 'ref', documentation: 'Reference to definition' },
  ]),
  el('gloss', 'Gloss or explanation', paraContent),
  el('soCalled', 'So-called', paraContent),
  el('mentioned', 'Mentioned word', paraContent),

  // Editorial
  el('abbr', 'Abbreviation', paraContent),
  el('expan', 'Expansion of abbreviation', paraContent),
  el('choice', 'Editorial choice', ['abbr', 'expan', 'orig', 'reg', 'sic', 'corr', 'seg']),
  el('orig', 'Original form', paraContent),
  el('reg', 'Regularized form', paraContent),
  el('sic', 'Apparent error in source', paraContent),
  el('corr', 'Correction', paraContent),
  el('add', 'Addition', paraContent, [
    { name: 'place', documentation: 'Place of addition (above, below, inline, margin)' },
  ]),
  el('del', 'Deletion', paraContent, [
    { name: 'rend', documentation: 'How rendered (strikethrough, overwritten, erased)' },
  ]),
  el('subst', 'Substitution', ['add', 'del']),
  el('supplied', 'Supplied text', paraContent, [
    { name: 'reason', documentation: 'Reason for supplying (damage, omitted, illegible)' },
  ]),
  el('unclear', 'Unclear text', paraContent, [
    { name: 'reason', documentation: 'Reason text is unclear' },
    { name: 'cert', values: ['high', 'medium', 'low'], documentation: 'Certainty' },
  ]),
  el('gap', 'Omission or gap', [], [
    { name: 'reason', documentation: 'Reason for gap (damage, illegible, sampling)' },
    { name: 'extent', documentation: 'Size of gap' },
    { name: 'unit', documentation: 'Unit (chars, words, lines, pages)' },
    { name: 'quantity', documentation: 'Number of units' },
  ]),

  // References & links
  el('ref', 'Reference or link', paraContent, [
    { name: 'target', documentation: 'Target URL or pointer' },
    { name: 'type', documentation: 'Type of reference' },
  ]),
  el('ptr', 'Pointer', [], [
    { name: 'target', documentation: 'Target URL or pointer' },
    { name: 'type', documentation: 'Type of pointer' },
  ]),
  el('note', 'Note or annotation', [...paraContent, 'p'], [
    { name: 'place', documentation: 'Where the note appears (foot, end, margin, inline)' },
    { name: 'type', documentation: 'Type of note' },
    { name: 'target', documentation: 'What the note is about' },
    { name: 'anchored', values: ['true', 'false'], documentation: 'Whether anchored' },
  ]),
  el('anchor', 'Anchor point', []),

  // Lists
  el('list', 'List', ['item', 'head', 'label', 'pb', 'lb'], [
    { name: 'type', documentation: 'Type (ordered, bulleted, gloss, simple)' },
  ]),
  el('item', 'List item', [...paraContent, 'p', 'list']),
  el('label', 'Label', paraContent),

  // Tables
  el('table', 'Table', ['row', 'head'], [
    { name: 'rows', documentation: 'Number of rows' },
    { name: 'cols', documentation: 'Number of columns' },
  ]),
  el('row', 'Table row', ['cell'], [
    { name: 'role', values: ['label', 'data'], documentation: 'Role of row' },
  ]),
  el('cell', 'Table cell', paraContent, [
    { name: 'role', values: ['label', 'data'], documentation: 'Role of cell' },
    { name: 'rows', documentation: 'Row span' },
    { name: 'cols', documentation: 'Column span' },
  ]),

  // Figures & graphics
  el('figure', 'Figure', ['graphic', 'head', 'figDesc', 'p'], [
    { name: 'type', documentation: 'Type of figure' },
  ]),
  el('graphic', 'Graphic', [], [
    { name: 'url', documentation: 'URL of the image' },
    { name: 'width', documentation: 'Width' },
    { name: 'height', documentation: 'Height' },
    { name: 'mimeType', documentation: 'MIME type' },
  ]),
  el('figDesc', 'Figure description', paraContent),

  // Milestones
  el('pb', 'Page break', [], [
    { name: 'n', documentation: 'Page number' },
    { name: 'facs', documentation: 'Facsimile reference' },
  ]),
  el('lb', 'Line break', [], [
    { name: 'n', documentation: 'Line number' },
  ]),
  el('cb', 'Column break', [], [
    { name: 'n', documentation: 'Column number' },
  ]),
  el('milestone', 'Milestone', [], [
    { name: 'unit', documentation: 'Type of section' },
    { name: 'n', documentation: 'Number' },
  ]),

  // Segments
  el('seg', 'Arbitrary segment', paraContent, [
    { name: 'type', documentation: 'Type of segment' },
    { name: 'function', documentation: 'Function' },
  ]),
  el('fw', 'Forme work (header/footer)', paraContent, [
    { name: 'type', documentation: 'Type (header, footer, pageNum, sig, catch)' },
    { name: 'place', documentation: 'Where it appears' },
  ]),

  // Critical apparatus
  el('app', 'Apparatus entry', ['lem', 'rdg', 'rdgGrp', 'note', 'witDetail']),
  el('lem', 'Lemma (base text reading)', paraContent, [
    { name: 'wit', documentation: 'Witness(es)' },
  ]),
  el('rdg', 'Reading (variant)', paraContent, [
    { name: 'wit', documentation: 'Witness(es)' },
    { name: 'type', documentation: 'Type of variant' },
  ]),
  el('witDetail', 'Witness detail', paraContent, [
    { name: 'wit', documentation: 'Witness' },
    { name: 'target', documentation: 'Target reading' },
  ]),

  // Manuscript description (simplified)
  el('msDesc', 'Manuscript description', ['msIdentifier', 'head', 'p', 'msContents', 'physDesc', 'history', 'additional']),
  el('msIdentifier', 'Manuscript identifier', ['settlement', 'institution', 'repository', 'collection', 'idno', 'altIdentifier', 'msName']),
];

/** Full TEI All has additional elements beyond Lite */
export const TEI_ALL_EXTRA_ELEMENTS: ElementSpec[] = [
  // Transcription
  el('facsimile', 'Facsimile', ['surface', 'surfaceGrp']),
  el('surface', 'Surface', ['graphic', 'zone'], [
    { name: 'ulx', documentation: 'Upper left x' },
    { name: 'uly', documentation: 'Upper left y' },
    { name: 'lrx', documentation: 'Lower right x' },
    { name: 'lry', documentation: 'Lower right y' },
  ]),
  el('zone', 'Zone on a surface', ['graphic', 'zone']),
  el('sourceDoc', 'Source document', ['surface', 'surfaceGrp']),

  // Corpus
  el('teiCorpus', 'TEI corpus', ['teiHeader', 'TEI']),
  el('particDesc', 'Participant description', ['person', 'personGrp', 'listPerson', 'p']),
  el('settingDesc', 'Setting description', ['setting', 'listPlace', 'p']),
  el('person', 'Person', ['persName', 'birth', 'death', 'age', 'sex', 'occupation', 'residence', 'note'], [
    { name: 'sex', documentation: 'Sex' },
    { name: 'age', documentation: 'Age' },
    { name: 'role', documentation: 'Role' },
  ]),
  el('listPerson', 'List of persons', ['person', 'personGrp', 'listPerson', 'head']),

  // Linking
  el('standOff', 'Stand-off markup', ['listAnnotation', 'listEvent', 'listPerson', 'listPlace', 'listOrg', 'listBibl']),
  el('listAnnotation', 'List of annotations', ['annotation']),
  el('annotation', 'Annotation', ['p', 'note'], [
    { name: 'target', documentation: 'Target of annotation' },
    { name: 'type', documentation: 'Type of annotation' },
  ]),

  // Correspondence
  el('correspDesc', 'Correspondence description', ['correspAction', 'correspContext', 'note']),
  el('correspAction', 'Correspondence action', ['persName', 'orgName', 'placeName', 'date', 'note'], [
    { name: 'type', values: ['sent', 'received', 'forwarded', 'redirected'], documentation: 'Type of action' },
  ]),

  // Named entities
  el('listPlace', 'List of places', ['place', 'listPlace', 'head']),
  el('place', 'Place', ['placeName', 'location', 'desc', 'note'], [
    { name: 'type', documentation: 'Type of place' },
  ]),
  el('listOrg', 'List of organizations', ['org', 'listOrg', 'head']),
  el('org', 'Organization', ['orgName', 'desc', 'note'], [
    { name: 'type', documentation: 'Type of organization' },
  ]),
  el('listEvent', 'List of events', ['event', 'listEvent', 'head']),
  el('event', 'Event', ['label', 'desc', 'note'], [
    { name: 'when', documentation: 'Date of event' },
    { name: 'from', documentation: 'Start date' },
    { name: 'to', documentation: 'End date' },
  ]),

  // Linguistic / analysis
  el('s', 'Sentence', paraContent, [
    { name: 'type', documentation: 'Type of sentence' },
  ]),
  el('w', 'Word', paraContent, [
    { name: 'lemma', documentation: 'Lemma form' },
    { name: 'pos', documentation: 'Part of speech' },
    { name: 'type', documentation: 'Type of word' },
  ]),
  el('c', 'Character', [], [
    { name: 'type', documentation: 'Type of character' },
  ]),
  el('pc', 'Punctuation character', [], [
    { name: 'force', values: ['strong', 'weak', 'inter'], documentation: 'Boundary strength' },
    { name: 'unit', documentation: 'Unit delimited' },
    { name: 'pre', values: ['true', 'false'], documentation: 'Precedes its unit' },
  ]),
  el('cl', 'Clause', paraContent, [
    { name: 'type', documentation: 'Type of clause' },
  ]),
  el('phr', 'Phrase', paraContent, [
    { name: 'type', documentation: 'Type of phrase' },
    { name: 'function', documentation: 'Grammatical function' },
  ]),
  el('span', 'Span of text with annotation', paraContent, [
    { name: 'from', documentation: 'Start point' },
    { name: 'to', documentation: 'End point' },
    { name: 'type', documentation: 'Type of annotation' },
  ]),
  el('interp', 'Interpretive annotation', ['p', 'desc'], [
    { name: 'type', documentation: 'Type of interpretation' },
    { name: 'inst', documentation: 'Instance pointer' },
  ]),
  el('interpGrp', 'Group of interpretations', ['interp', 'interpGrp'], [
    { name: 'type', documentation: 'Type of interpretation group' },
  ]),

  // Transcription (additional)
  el('handShift', 'Hand shift', [], [
    { name: 'new', documentation: 'New hand' },
    { name: 'medium', documentation: 'Writing medium' },
  ]),
  el('damage', 'Damaged text', paraContent, [
    { name: 'type', documentation: 'Type of damage' },
    { name: 'degree', documentation: 'Degree of damage' },
    { name: 'agent', documentation: 'Cause of damage' },
  ]),
  el('surplus', 'Surplus text', paraContent, [
    { name: 'reason', documentation: 'Reason text is surplus' },
  ]),

  // Dictionaries
  el('entry', 'Dictionary entry', ['form', 'gramGrp', 'sense', 'etym', 'note', 're']),
  el('form', 'Form of a word', ['orth', 'pron', 'hyph', 'syll', 'stress'], [
    { name: 'type', values: ['lemma', 'variant', 'compound', 'derivative', 'inflected'], documentation: 'Form type' },
  ]),
  el('orth', 'Orthographic form', paraContent),
  el('sense', 'Sense of a word', ['def', 'cit', 'note', 'sense', 'usg', 'xr']),
  el('def', 'Definition', paraContent),

  // Title page (for prose template)
  el('titlePage', 'Title page', ['docTitle', 'byline', 'docAuthor', 'docEdition', 'docImprint', 'docDate', 'epigraph', 'figure']),
  el('docTitle', 'Document title on title page', ['titlePart']),
  el('titlePart', 'Part of a title', paraContent, [
    { name: 'type', values: ['main', 'sub', 'alt', 'short', 'desc'], documentation: 'Type of title part' },
  ]),
  el('docAuthor', 'Author on title page', paraContent),
  el('docDate', 'Date on title page', paraContent, [
    { name: 'when', documentation: 'Normalized date' },
  ]),
];

// ============================================================================
// TEI Manuscript Description Module (msdescription)
// ============================================================================

export const TEI_MSDESC_ELEMENTS: ElementSpec[] = [
  // Core manuscript content
  el('msContents', 'Intellectual content of manuscript', ['summary', 'msItem', 'msItemStruct', 'textLang', 'p']),
  el('msItem', 'Individual work in manuscript', ['locus', 'locusGrp', 'author', 'respStmt', 'title', 'rubric', 'incipit', 'quote', 'explicit', 'finalRubric', 'colophon', 'decoNote', 'listBibl', 'bibl', 'filiation', 'note', 'textLang', 'msItem'], [
    { name: 'class', documentation: 'Classification of the item' },
    { name: 'defective', values: ['true', 'false', 'unknown'], documentation: 'Whether the item is defective' },
  ]),
  el('msItemStruct', 'Structured description of a manuscript item', ['locus', 'author', 'title', 'rubric', 'incipit', 'explicit', 'finalRubric', 'colophon', 'note', 'textLang', 'filiation', 'listBibl']),
  el('summary', 'Overview of the intellectual content', paraContent),
  el('incipit', 'Opening words of a text', paraContent, [
    { name: 'defective', values: ['true', 'false', 'unknown'], documentation: 'Whether the incipit is defective' },
  ]),
  el('explicit', 'Closing words of a text', paraContent, [
    { name: 'defective', values: ['true', 'false', 'unknown'], documentation: 'Whether the explicit is defective' },
  ]),
  el('rubric', 'Title or heading as given in the manuscript', paraContent),
  el('finalRubric', 'Final title or colophon', paraContent),
  el('colophon', 'Colophon of a manuscript', paraContent),
  el('filiation', 'Information about the manuscript\'s place in a stemma', paraContent),
  el('locus', 'Reference to a location in a manuscript', paraContent, [
    { name: 'from', documentation: 'Starting folio/page' },
    { name: 'to', documentation: 'Ending folio/page' },
    { name: 'scheme', documentation: 'Foliation scheme' },
  ]),
  el('locusGrp', 'Group of loci', ['locus']),
  el('textLang', 'Languages and writing systems of the intellectual content', paraContent, [
    { name: 'mainLang', documentation: 'Principal language' },
    { name: 'otherLangs', documentation: 'Other languages' },
  ]),

  // Physical description
  el('physDesc', 'Physical description of the manuscript', ['p', 'objectDesc', 'handDesc', 'scriptDesc', 'typeDesc', 'decoDesc', 'additions', 'bindingDesc', 'sealDesc', 'accMat', 'musicNotation']),
  el('objectDesc', 'Description of the physical components', ['p', 'supportDesc', 'layoutDesc'], [
    { name: 'form', documentation: 'Form of the object (codex, scroll, etc.)' },
  ]),
  el('supportDesc', 'Description of the materials', ['p', 'support', 'extent', 'foliation', 'collation', 'condition'], [
    { name: 'material', documentation: 'Material (parchment, paper, etc.)' },
  ]),
  el('support', 'Description of the physical support', ['p', 'material', 'watermark']),
  el('material', 'Material of the support', paraContent),
  el('watermark', 'Watermark description', paraContent),
  el('extent', 'Size or extent of the manuscript', ['measure', 'dimensions', 'p']),
  el('dimensions', 'Dimensions of the object', ['height', 'width', 'depth', 'dim'], [
    { name: 'type', documentation: 'What is measured (leaf, written, binding)' },
    { name: 'unit', documentation: 'Unit of measurement' },
  ]),
  el('height', 'Height', paraContent, [
    { name: 'quantity', documentation: 'Numeric value' },
    { name: 'unit', documentation: 'Unit' },
  ]),
  el('width', 'Width', paraContent, [
    { name: 'quantity', documentation: 'Numeric value' },
    { name: 'unit', documentation: 'Unit' },
  ]),
  el('depth', 'Depth', paraContent, [
    { name: 'quantity', documentation: 'Numeric value' },
    { name: 'unit', documentation: 'Unit' },
  ]),
  el('dim', 'Single dimension', paraContent, [
    { name: 'type', documentation: 'Type of dimension' },
  ]),
  el('foliation', 'Description of the foliation scheme', paraContent),
  el('collation', 'Description of the quire structure', ['p', 'formula', 'catchwords', 'signatures']),
  el('formula', 'Collation formula', paraContent),
  el('catchwords', 'Description of catchwords', paraContent),
  el('signatures', 'Description of quire signatures', paraContent),
  el('condition', 'Physical condition of the manuscript', ['p']),
  el('layoutDesc', 'Description of the layout', ['layout', 'p', 'summary']),
  el('layout', 'Description of a single layout scheme', ['p'], [
    { name: 'columns', documentation: 'Number of columns' },
    { name: 'writtenLines', documentation: 'Number of written lines' },
    { name: 'ruledLines', documentation: 'Number of ruled lines' },
  ]),

  // Hand and script description
  el('handDesc', 'Description of hands used in the manuscript', ['handNote', 'p', 'summary'], [
    { name: 'hands', documentation: 'Number of hands' },
  ]),
  el('handNote', 'Description of a particular hand', ['p', 'persName', 'locus'], [
    { name: 'scribe', documentation: 'Identifier of the scribe' },
    { name: 'script', documentation: 'Type of script' },
    { name: 'medium', documentation: 'Writing medium' },
    { name: 'scope', values: ['sole', 'major', 'minor'], documentation: 'Extent of the hand' },
  ]),
  el('scriptDesc', 'Description of scripts used', ['scriptNote', 'p', 'summary']),
  el('scriptNote', 'Description of a particular script', ['p'], [
    { name: 'script', documentation: 'Type of script' },
  ]),
  el('typeDesc', 'Description of types used', ['typeNote', 'p', 'summary']),
  el('typeNote', 'Description of a particular type', ['p']),

  // Decoration
  el('decoDesc', 'Description of decorative components', ['decoNote', 'p', 'summary']),
  el('decoNote', 'Description of a decorative component', ['p', 'list'], [
    { name: 'type', documentation: 'Type of decoration' },
  ]),

  // Additions and binding
  el('additions', 'Later additions to the manuscript', ['p', 'list']),
  el('bindingDesc', 'Description of the binding', ['binding', 'p', 'condition', 'decoNote']),
  el('binding', 'Description of a single binding', ['p', 'condition', 'decoNote'], [
    { name: 'contemporary', values: ['true', 'false', 'unknown'], documentation: 'Whether binding is contemporary' },
  ]),
  el('sealDesc', 'Description of seals', ['seal', 'p', 'decoNote']),
  el('seal', 'Description of a single seal', ['p', 'decoNote'], [
    { name: 'type', documentation: 'Type of seal' },
    { name: 'contemporary', values: ['true', 'false', 'unknown'], documentation: 'Whether seal is contemporary' },
  ]),
  el('accMat', 'Accompanying material', ['p', 'list']),
  el('musicNotation', 'Description of musical notation', ['p', 'term']),

  // History
  el('history', 'History of the manuscript', ['p', 'summary', 'origin', 'provenance', 'acquisition']),
  el('origin', 'Origin of the manuscript', ['p', 'origPlace', 'origDate']),
  el('origPlace', 'Place of origin', paraContent, [
    { name: 'ref', documentation: 'Reference to a place authority' },
  ]),
  el('origDate', 'Date of origin', paraContent, [
    { name: 'when', documentation: 'Normalized date' },
    { name: 'notBefore', documentation: 'Earliest possible date' },
    { name: 'notAfter', documentation: 'Latest possible date' },
  ]),
  el('provenance', 'Provenance record', ['p'], [
    { name: 'when', documentation: 'Date of this provenance event' },
    { name: 'notBefore', documentation: 'Earliest possible date' },
    { name: 'notAfter', documentation: 'Latest possible date' },
  ]),
  el('acquisition', 'Acquisition of the manuscript', ['p'], [
    { name: 'when', documentation: 'Date of acquisition' },
    { name: 'notBefore', documentation: 'Earliest possible date' },
    { name: 'notAfter', documentation: 'Latest possible date' },
  ]),

  // Additional information
  el('additional', 'Additional information', ['p', 'adminInfo', 'surrogates', 'listBibl']),
  el('adminInfo', 'Administrative information', ['p', 'recordHist', 'availability', 'custodialHist', 'note']),
  el('recordHist', 'Record history', ['p', 'source', 'change']),
  el('custodialHist', 'Custodial history', ['custEvent', 'p']),
  el('custEvent', 'Custodial event', ['p'], [
    { name: 'type', documentation: 'Type of event' },
    { name: 'when', documentation: 'Date of event' },
  ]),
  el('surrogates', 'Information about surrogates', ['p', 'bibl', 'listBibl']),

  // Identifier extensions
  el('institution', 'Institution holding the manuscript', paraContent),
  el('repository', 'Repository holding the manuscript', paraContent),
  el('collection', 'Collection containing the manuscript', paraContent),
  el('altIdentifier', 'Alternative identifier', ['settlement', 'institution', 'repository', 'collection', 'idno', 'note'], [
    { name: 'type', documentation: 'Type of identifier' },
  ]),
  el('msName', 'Alternative name for the manuscript', paraContent),

  // Bibliographic extensions
  el('listBibl', 'List of bibliographic references', ['bibl', 'biblStruct', 'listBibl', 'head']),
  el('biblStruct', 'Structured bibliographic reference', ['analytic', 'monogr', 'series', 'note', 'idno', 'relatedItem']),
  el('analytic', 'Analytic level (article, chapter)', ['author', 'editor', 'respStmt', 'title', 'date', 'idno']),
  el('monogr', 'Monographic level (book, journal)', ['author', 'editor', 'respStmt', 'title', 'edition', 'imprint', 'biblScope', 'extent', 'idno']),
  el('series', 'Series statement', ['title', 'biblScope', 'idno', 'respStmt', 'editor']),
  el('imprint', 'Publication information', ['publisher', 'pubPlace', 'date', 'biblScope']),
  el('biblScope', 'Scope of bibliographic reference', paraContent, [
    { name: 'unit', documentation: 'Unit (page, volume, issue)' },
    { name: 'from', documentation: 'Starting value' },
    { name: 'to', documentation: 'Ending value' },
  ]),
  el('edition', 'Edition statement', paraContent),
  el('biblFull', 'Full bibliographic description', ['titleStmt', 'editionStmt', 'extent', 'publicationStmt', 'seriesStmt', 'notesStmt', 'sourceDesc']),
  el('relatedItem', 'Related item', ['bibl', 'biblStruct', 'biblFull', 'p'], [
    { name: 'type', documentation: 'Type of relationship' },
    { name: 'target', documentation: 'Target of relationship' },
  ]),
];

// ============================================================================
// TEI Header Extensions Module
// ============================================================================

export const TEI_HEADER_EXTRA_ELEMENTS: ElementSpec[] = [
  // Abstract and creation
  el('abstract', 'Summary of the content', ['p', ...paraContent]),
  el('creation', 'Information about creation', ['date', 'placeName', 'persName', 'p', ...paraContent]),

  // Language usage
  el('langUsage', 'Languages used in the text', ['language', 'p']),
  el('language', 'Language used', paraContent, [
    { name: 'ident', documentation: 'Language code' },
    { name: 'usage', documentation: 'Approximate percentage' },
  ]),

  // Text classification
  el('textClass', 'Text classification', ['keywords', 'classCode', 'catRef']),
  el('keywords', 'Keywords', ['term', 'list'], [
    { name: 'scheme', documentation: 'Scheme of keywords' },
  ]),
  el('classCode', 'Classification code', paraContent, [
    { name: 'scheme', documentation: 'Classification scheme' },
  ]),
  el('catRef', 'Category reference', [], [
    { name: 'target', documentation: 'Target category' },
    { name: 'scheme', documentation: 'Classification scheme' },
  ]),
  el('taxonomy', 'Taxonomy definition', ['category', 'taxonomy', 'desc', 'bibl']),
  el('category', 'Category in a taxonomy', ['catDesc', 'category'], [
    { name: 'xml:id', documentation: 'Category identifier' },
  ]),
  el('catDesc', 'Category description', paraContent),
  el('classDecl', 'Classification declarations', ['taxonomy']),

  // Tags declaration
  el('tagsDecl', 'Tags declaration', ['rendition', 'namespace', 'tagUsage']),
  el('tagUsage', 'Usage information for an element', [], [
    { name: 'gi', documentation: 'Generic identifier (element name)' },
    { name: 'occurs', documentation: 'Number of occurrences' },
  ]),
  el('rendition', 'Rendition information', paraContent, [
    { name: 'xml:id', documentation: 'Rendition identifier' },
    { name: 'scheme', documentation: 'Rendition scheme (css, xslfo)' },
    { name: 'scope', documentation: 'Scope (selector)' },
  ]),
  el('namespace', 'Namespace declaration', ['tagUsage'], [
    { name: 'name', documentation: 'Namespace URI' },
  ]),

  // References declaration
  el('refsDecl', 'References declaration', ['cRefPattern', 'refState', 'p']),
  el('cRefPattern', 'Canonical reference pattern', ['p'], [
    { name: 'matchPattern', documentation: 'Regex to match' },
    { name: 'replacementPattern', documentation: 'Replacement XPath' },
  ]),
  el('refState', 'Reference state', [], [
    { name: 'unit', documentation: 'Unit of reference' },
    { name: 'length', documentation: 'Length in characters' },
    { name: 'delim', documentation: 'Delimiter' },
  ]),

  // Project description
  el('projectDesc', 'Project description', ['p']),
  el('samplingDecl', 'Sampling declaration', ['p']),

  // Editorial declaration
  el('editorialDecl', 'Editorial declaration', ['p', 'correction', 'normalization', 'quotation', 'hyphenation', 'segmentation', 'stdVals', 'interpretation', 'punctuation']),
  el('correction', 'Correction principles', ['p'], [
    { name: 'status', values: ['high', 'medium', 'low', 'unknown'], documentation: 'Correction status' },
    { name: 'method', values: ['silent', 'markup'], documentation: 'Correction method' },
  ]),
  el('normalization', 'Normalization principles', ['p'], [
    { name: 'method', values: ['silent', 'markup'], documentation: 'Normalization method' },
    { name: 'source', documentation: 'Authority for normalization' },
  ]),
  el('quotation', 'Quotation handling', ['p'], [
    { name: 'marks', values: ['none', 'some', 'all'], documentation: 'Quotation marks handling' },
  ]),
  el('hyphenation', 'Hyphenation handling', ['p'], [
    { name: 'eol', values: ['all', 'some', 'none', 'hard'], documentation: 'End-of-line hyphenation' },
  ]),
  el('segmentation', 'Segmentation principles', ['p']),
  el('stdVals', 'Standard values', ['p']),
  el('interpretation', 'Interpretation principles', ['p']),
  el('punctuation', 'Punctuation handling', ['p'], [
    { name: 'marks', values: ['none', 'some', 'all'], documentation: 'Punctuation handling' },
    { name: 'placement', values: ['internal', 'external'], documentation: 'Placement' },
  ]),

  // Application info
  el('appInfo', 'Application information', ['application']),
  el('application', 'Application used', ['label', 'p'], [
    { name: 'ident', documentation: 'Application identifier' },
    { name: 'version', documentation: 'Version number' },
    { name: 'when', documentation: 'Date used' },
  ]),

  // XenoData
  el('xenoData', 'Non-TEI metadata', paraContent),

  // Statement groups
  el('editionStmt', 'Edition statement', ['edition', 'p', 'respStmt']),
  el('seriesStmt', 'Series statement', ['title', 'idno', 'respStmt', 'biblScope', 'p']),
  el('notesStmt', 'Notes statement', ['note', 'relatedItem']),

  // Misc header elements
  el('funder', 'Funding body', paraContent, [
    { name: 'ref', documentation: 'Reference to funder record' },
  ]),
  el('principal', 'Principal researcher', paraContent, [
    { name: 'ref', documentation: 'Reference to person record' },
  ]),
  el('sponsor', 'Sponsoring organization', paraContent, [
    { name: 'ref', documentation: 'Reference to org record' },
  ]),
  el('authority', 'Release authority', paraContent),
  el('distributor', 'Distributor', paraContent),
  el('address', 'Postal or electronic address', ['addrLine', 'street', 'postCode', 'postBox', 'settlement', 'region', 'country', 'name']),
  el('addrLine', 'Address line', paraContent),
  el('street', 'Street address', paraContent),
  el('postCode', 'Postal code', paraContent),
  el('postBox', 'Post office box', paraContent),
];

// ============================================================================
// TEI Names and Dates Module (namesdates)
// ============================================================================

export const TEI_NAMESDATES_ELEMENTS: ElementSpec[] = [
  // Person components
  el('birth', 'Birth information', ['date', 'placeName', 'p', ...paraContent], [
    { name: 'when', documentation: 'Date of birth' },
    { name: 'notBefore', documentation: 'Earliest possible date' },
    { name: 'notAfter', documentation: 'Latest possible date' },
  ]),
  el('death', 'Death information', ['date', 'placeName', 'p', ...paraContent], [
    { name: 'when', documentation: 'Date of death' },
    { name: 'notBefore', documentation: 'Earliest possible date' },
    { name: 'notAfter', documentation: 'Latest possible date' },
  ]),
  el('floruit', 'Floruit period', ['date', 'p', ...paraContent], [
    { name: 'when', documentation: 'Floruit date' },
    { name: 'notBefore', documentation: 'Earliest possible date' },
    { name: 'notAfter', documentation: 'Latest possible date' },
  ]),
  el('residence', 'Place of residence', ['placeName', 'p', ...paraContent], [
    { name: 'from', documentation: 'Start of residence' },
    { name: 'to', documentation: 'End of residence' },
  ]),
  el('affiliation', 'Organizational affiliation', ['orgName', 'p', ...paraContent], [
    { name: 'from', documentation: 'Start of affiliation' },
    { name: 'to', documentation: 'End of affiliation' },
  ]),
  el('education', 'Education information', ['p', ...paraContent], [
    { name: 'from', documentation: 'Start date' },
    { name: 'to', documentation: 'End date' },
  ]),
  el('faith', 'Religious faith', ['p', ...paraContent]),
  el('langKnowledge', 'Language knowledge', ['langKnown', 'p']),
  el('langKnown', 'Known language', paraContent, [
    { name: 'tag', documentation: 'Language tag' },
    { name: 'level', documentation: 'Proficiency level' },
  ]),
  el('nationality', 'Nationality', ['p', ...paraContent], [
    { name: 'key', documentation: 'Nationality code' },
    { name: 'from', documentation: 'Start date' },
    { name: 'to', documentation: 'End date' },
  ]),
  el('occupation', 'Occupation', ['p', ...paraContent], [
    { name: 'scheme', documentation: 'Occupation scheme' },
    { name: 'code', documentation: 'Occupation code' },
    { name: 'from', documentation: 'Start date' },
    { name: 'to', documentation: 'End date' },
  ]),
  el('sex', 'Sex', paraContent, [
    { name: 'value', documentation: 'Sex value' },
  ]),
  el('age', 'Age', paraContent, [
    { name: 'value', documentation: 'Numeric age' },
  ]),
  el('socecStatus', 'Socio-economic status', ['p', ...paraContent], [
    { name: 'scheme', documentation: 'Status scheme' },
    { name: 'code', documentation: 'Status code' },
  ]),
  el('trait', 'Trait or characteristic', ['p', 'label', 'desc'], [
    { name: 'type', documentation: 'Type of trait' },
  ]),
  el('state', 'State or status', ['p', 'label', 'desc'], [
    { name: 'type', documentation: 'Type of state' },
    { name: 'from', documentation: 'Start date' },
    { name: 'to', documentation: 'End date' },
  ]),

  // Person name components
  el('genName', 'Generational component (Jr., III)', paraContent),
  el('roleName', 'Role or position', paraContent, [
    { name: 'type', documentation: 'Type of role' },
  ]),
  el('addName', 'Additional name', paraContent, [
    { name: 'type', documentation: 'Type of additional name' },
  ]),
  el('nameLink', 'Connecting element in a name', paraContent),

  // Groups
  el('personGrp', 'Group of persons', ['persName', 'occupation', 'sex', 'age', 'p'], [
    { name: 'role', documentation: 'Role of the group' },
    { name: 'sex', documentation: 'Predominant sex' },
    { name: 'size', documentation: 'Size of group' },
  ]),

  // Place components
  el('location', 'Location of a place', ['geo', 'address', 'placeName', 'country', 'region', 'settlement', 'p']),
  el('geo', 'Geographic coordinates', paraContent, [
    { name: 'decls', documentation: 'Coordinate reference system' },
  ]),
  el('bloc', 'Bloc or supranational grouping', paraContent),
  el('geogName', 'Geographic name', paraContent, [
    { name: 'type', documentation: 'Type of geographic feature' },
  ]),
  el('geogFeat', 'Geographic feature', paraContent),
  el('climate', 'Climate description', ['p', 'ab']),
  el('terrain', 'Terrain description', ['p', 'ab']),
  el('population', 'Population information', ['p', 'ab'], [
    { name: 'when', documentation: 'Date of population count' },
    { name: 'quantity', documentation: 'Population number' },
  ]),

  // Relations
  el('relation', 'Relationship between entities', [], [
    { name: 'type', documentation: 'Type of relation' },
    { name: 'name', documentation: 'Name of relation' },
    { name: 'active', documentation: 'Active participant' },
    { name: 'passive', documentation: 'Passive participant' },
    { name: 'mutual', documentation: 'Mutual participants' },
  ]),
  el('relationGrp', 'Group of relations', ['relation', 'relationGrp', 'desc'], [
    { name: 'type', documentation: 'Type of relation group' },
  ]),
  el('listRelation', 'List of relations', ['relation', 'relationGrp', 'listRelation', 'head', 'desc']),

  // Event description
  el('desc', 'Description', paraContent),

  // Setting
  el('setting', 'Setting description', ['p', 'name', 'placeName', 'date', 'time', 'locale', 'activity']),
  el('time', 'Time reference', paraContent, [
    { name: 'when', documentation: 'Normalized time' },
  ]),
  el('locale', 'Locale description', paraContent),
  el('activity', 'Activity description', paraContent),
];

// ============================================================================
// TEI Text Criticism Module (textcrit)
// ============================================================================

export const TEI_TEXTCRIT_ELEMENTS: ElementSpec[] = [
  // Witness list
  el('listWit', 'List of witnesses', ['witness', 'listWit', 'head']),
  el('witness', 'Witness description', ['bibl', 'biblStruct', 'msDesc', 'p', ...paraContent], [
    { name: 'xml:id', documentation: 'Witness identifier (e.g., "A", "B")' },
  ]),

  // Apparatus extensions
  el('rdgGrp', 'Group of readings', ['rdg', 'rdgGrp', 'note'], [
    { name: 'type', documentation: 'Type of reading group' },
  ]),
  el('lacunaStart', 'Start of lacuna', [], [
    { name: 'wit', documentation: 'Witness(es)' },
  ]),
  el('lacunaEnd', 'End of lacuna', [], [
    { name: 'wit', documentation: 'Witness(es)' },
  ]),
  el('witStart', 'Start of witness reading', [], [
    { name: 'wit', documentation: 'Witness' },
  ]),
  el('witEnd', 'End of witness reading', [], [
    { name: 'wit', documentation: 'Witness' },
  ]),
  el('variantEncoding', 'Variant encoding method', [], [
    { name: 'method', values: ['location-referenced', 'double-end-point', 'parallel-segmentation'], documentation: 'Encoding method' },
    { name: 'location', values: ['internal', 'external'], documentation: 'Location of apparatus' },
  ]),
];

// ============================================================================
// TEI Linking Module
// ============================================================================

export const TEI_LINKING_ELEMENTS: ElementSpec[] = [
  el('link', 'Association between elements', [], [
    { name: 'targets', documentation: 'Target elements' },
    { name: 'type', documentation: 'Type of link' },
  ]),
  el('linkGrp', 'Group of links', ['link', 'linkGrp'], [
    { name: 'type', documentation: 'Type of link group' },
  ]),
  el('join', 'Join elements', [], [
    { name: 'targets', documentation: 'Target elements to join' },
    { name: 'result', documentation: 'Result element type' },
  ]),
  el('joinGrp', 'Group of joins', ['join', 'joinGrp'], [
    { name: 'result', documentation: 'Result element type' },
  ]),
  el('alt', 'Alternation', [], [
    { name: 'targets', documentation: 'Alternative targets' },
    { name: 'mode', values: ['excl', 'incl'], documentation: 'Exclusion or inclusion' },
    { name: 'weights', documentation: 'Weights for alternatives' },
  ]),
  el('altGrp', 'Group of alternations', ['alt', 'altGrp'], [
    { name: 'mode', values: ['excl', 'incl'], documentation: 'Exclusion or inclusion' },
  ]),
  el('timeline', 'Timeline', ['when'], [
    { name: 'origin', documentation: 'Origin point' },
    { name: 'unit', documentation: 'Time unit' },
  ]),
  el('when', 'Point in time', [], [
    { name: 'absolute', documentation: 'Absolute time' },
    { name: 'since', documentation: 'Reference point' },
    { name: 'interval', documentation: 'Interval from reference' },
    { name: 'unit', documentation: 'Time unit' },
  ]),
];

// ============================================================================
// TEI Analysis Module
// ============================================================================

export const TEI_ANALYSIS_ELEMENTS: ElementSpec[] = [
  el('spanGrp', 'Group of spans', ['span', 'spanGrp'], [
    { name: 'type', documentation: 'Type of span group' },
  ]),
];

// ============================================================================
// TEI Transcription Module Extensions (transcr)
// ============================================================================

export const TEI_TRANSCR_ELEMENTS: ElementSpec[] = [
  el('surfaceGrp', 'Group of surfaces', ['surface', 'surfaceGrp']),
  el('line', 'Line on a surface', paraContent, [
    { name: 'ulx', documentation: 'Upper left x' },
    { name: 'uly', documentation: 'Upper left y' },
    { name: 'lrx', documentation: 'Lower right x' },
    { name: 'lry', documentation: 'Lower right y' },
  ]),
  el('path', 'SVG path for zone shape', [], [
    { name: 'points', documentation: 'SVG path data' },
  ]),
  el('mod', 'Modification (add, del, subst)', ['add', 'del', 'unclear', ...paraContent], [
    { name: 'type', documentation: 'Type of modification' },
  ]),
  el('redo', 'Reinstatement of deleted text', paraContent, [
    { name: 'target', documentation: 'What is reinstated' },
  ]),
  el('undo', 'Cancellation of an addition', paraContent, [
    { name: 'target', documentation: 'What is undone' },
  ]),
  el('retrace', 'Retracing of text', paraContent),
  el('restore', 'Restoration of text', paraContent, [
    { name: 'type', documentation: 'Type of restoration' },
  ]),
  el('space', 'Significant space', [], [
    { name: 'quantity', documentation: 'Amount of space' },
    { name: 'unit', documentation: 'Unit of space' },
    { name: 'dim', values: ['horizontal', 'vertical'], documentation: 'Direction' },
  ]),
  el('metamark', 'Mark in the source not part of content', paraContent, [
    { name: 'function', documentation: 'Function of metamark' },
    { name: 'place', documentation: 'Location of metamark' },
    { name: 'target', documentation: 'What it refers to' },
  ]),
  el('transpose', 'Transposition of elements', ['ptr'], [
    { name: 'type', documentation: 'Type of transposition' },
  ]),
  el('transposition', 'Group of transpositions', ['transpose']),
  el('listTranspose', 'List of transpositions', ['transpose', 'listTranspose']),
  el('listChange', 'List of changes', ['change', 'listChange']),
];

// ============================================================================
// TEI Gaiji Module (special characters)
// ============================================================================

export const TEI_GAIJI_ELEMENTS: ElementSpec[] = [
  el('charDecl', 'Character declarations', ['char', 'glyph', 'desc']),
  el('char', 'Character definition', ['charName', 'charProp', 'mapping', 'figure', 'note', 'desc'], [
    { name: 'xml:id', documentation: 'Character identifier' },
  ]),
  el('charName', 'Character name', paraContent),
  el('charProp', 'Character property', ['unicodeName', 'localName', 'value']),
  el('unicodeName', 'Unicode property name', paraContent),
  el('localName', 'Local property name', paraContent),
  el('value', 'Property value', paraContent),
  el('g', 'Special character reference', paraContent, [
    { name: 'ref', documentation: 'Reference to character definition' },
  ]),
  el('glyph', 'Glyph definition', ['glyphName', 'charProp', 'mapping', 'figure', 'note', 'desc'], [
    { name: 'xml:id', documentation: 'Glyph identifier' },
  ]),
  el('glyphName', 'Glyph name', paraContent),
  el('mapping', 'Character mapping', paraContent, [
    { name: 'type', documentation: 'Type of mapping' },
  ]),
];

// ============================================================================
// TEI Verse Module
// ============================================================================

export const TEI_VERSE_ELEMENTS: ElementSpec[] = [
  el('caesura', 'Metrical pause', []),
  el('rhyme', 'Rhyming element', paraContent, [
    { name: 'label', documentation: 'Rhyme scheme label' },
    { name: 'type', documentation: 'Type of rhyme' },
  ]),
  el('metSym', 'Metrical symbol', paraContent, [
    { name: 'value', documentation: 'Symbol value' },
    { name: 'terminal', values: ['true', 'false'], documentation: 'Terminal symbol' },
  ]),
  el('metDecl', 'Metrical declaration', ['metSym', 'p'], [
    { name: 'type', documentation: 'Type of meter' },
    { name: 'pattern', documentation: 'Metrical pattern' },
  ]),
];

// ============================================================================
// TEI Spoken Module (spoken texts / transcriptions)
// ============================================================================

export const TEI_SPOKEN_ELEMENTS: ElementSpec[] = [
  el('u', 'Utterance', [...paraContent, 'pause', 'vocal', 'kinesic', 'incident'], [
    { name: 'who', documentation: 'Speaker' },
    { name: 'trans', values: ['smooth', 'latching', 'overlap', 'pause'], documentation: 'Transition type' },
  ]),
  el('pause', 'Pause in speech', [], [
    { name: 'dur', documentation: 'Duration' },
    { name: 'type', documentation: 'Type of pause' },
  ]),
  el('vocal', 'Vocalization', paraContent, [
    { name: 'type', documentation: 'Type (e.g., cough, laugh)' },
    { name: 'who', documentation: 'Who made the sound' },
  ]),
  el('kinesic', 'Kinesic movement', paraContent, [
    { name: 'type', documentation: 'Type of movement' },
    { name: 'who', documentation: 'Who made the movement' },
  ]),
  el('incident', 'External event', paraContent, [
    { name: 'type', documentation: 'Type of incident' },
  ]),
  el('writing', 'Written material in spoken text', paraContent, [
    { name: 'type', documentation: 'Type of writing' },
    { name: 'who', documentation: 'Who wrote it' },
  ]),
  el('shift', 'Shift in vocal quality', [], [
    { name: 'feature', documentation: 'Changed feature' },
    { name: 'new', documentation: 'New value' },
  ]),
  el('broadcast', 'Broadcast metadata', ['p', 'bibl', 'recording']),
  el('recording', 'Recording metadata', ['p', 'date', 'respStmt', 'equipment'], [
    { name: 'type', values: ['audio', 'video'], documentation: 'Recording type' },
    { name: 'dur', documentation: 'Duration' },
  ]),
  el('equipment', 'Recording equipment', ['p']),
  el('scriptStmt', 'Script statement', ['p', 'bibl']),
];

// ============================================================================
// TEI Figures and Tables Extensions
// ============================================================================

export const TEI_FIGURES_ELEMENTS: ElementSpec[] = [
  el('formula', 'Mathematical formula', paraContent, [
    { name: 'notation', documentation: 'Notation system (e.g., TeX, MathML)' },
  ]),
  el('notatedMusic', 'Notated music', ['graphic', 'binaryObject', 'ptr'], [
    { name: 'type', documentation: 'Notation type' },
  ]),
  el('binaryObject', 'Binary data', [], [
    { name: 'mimeType', documentation: 'MIME type' },
    { name: 'encoding', documentation: 'Encoding (e.g., base64)' },
  ]),
  el('media', 'Media object', [], [
    { name: 'url', documentation: 'URL' },
    { name: 'mimeType', documentation: 'MIME type' },
    { name: 'width', documentation: 'Width' },
    { name: 'height', documentation: 'Height' },
  ]),
];

// ============================================================================
// P5 Generated Data Integration
// ============================================================================

import {
  TEI_P5_ELEMENTS,
  getElementAttributes as getP5ElementAttributes,
  getP5Stats,
} from './teiP5Generated';

/**
 * Convert P5 element definition to ElementSpec with resolved attributes
 */
function p5ToElementSpec(p5El: typeof TEI_P5_ELEMENTS[0]): ElementSpec {
  return {
    name: p5El.name,
    documentation: p5El.documentation,
    children: p5El.children,
    // Resolve all attributes including inherited class attributes
    attributes: getP5ElementAttributes(p5El.name),
  };
}

// Cache for converted P5 elements
let cachedP5Elements: ElementSpec[] | null = null;

/**
 * Get all TEI P5 elements with resolved attributes
 */
function getP5AllElements(): ElementSpec[] {
  if (cachedP5Elements) return cachedP5Elements;

  cachedP5Elements = TEI_P5_ELEMENTS.map(p5ToElementSpec);
  return cachedP5Elements;
}

// ============================================================================
// Utility function to get all TEI elements
// ============================================================================

/**
 * Get all TEI Lite elements with P5 attribute class resolution
 * Merges static TEI_LITE_ELEMENTS with P5 attribute data
 */
export function getTeiLiteElements(): ElementSpec[] {
  const p5Elements = getP5AllElements();
  const p5Map = new Map<string, ElementSpec>();
  for (const el of p5Elements) {
    p5Map.set(el.name, el);
  }

  // Merge: use static definition but enrich with P5 attributes
  return TEI_LITE_ELEMENTS.map(staticEl => {
    const p5El = p5Map.get(staticEl.name);
    if (p5El) {
      // Merge attributes: P5 class-resolved attrs + static local attrs
      const mergedAttrs = mergeAttributes(p5El.attributes ?? [], staticEl.attributes ?? []);
      return {
        ...staticEl,
        attributes: mergedAttrs,
      };
    }
    return staticEl;
  });
}

/**
 * Get all TEI All elements (includes all modules)
 * Now uses P5 generated data for comprehensive 588-element coverage
 */
export function getTeiAllElements(): ElementSpec[] {
  // Use P5 data as the primary source (588 elements, 85 attribute classes)
  const p5Elements = getP5AllElements();

  // Use a Map to merge: P5 data is primary, static data fills gaps
  const elementMap = new Map<string, ElementSpec>();

  // First, add all P5 elements
  for (const el of p5Elements) {
    elementMap.set(el.name, el);
  }

  // Then, for elements that exist in both, prefer static data for
  // better documentation and more complete children lists
  // (P5's macro expansion may miss some valid children)
  const staticArrays = [
    TEI_LITE_ELEMENTS,
    TEI_ALL_EXTRA_ELEMENTS,
    TEI_MSDESC_ELEMENTS,
    TEI_HEADER_EXTRA_ELEMENTS,
    TEI_NAMESDATES_ELEMENTS,
    TEI_TEXTCRIT_ELEMENTS,
    TEI_LINKING_ELEMENTS,
    TEI_ANALYSIS_ELEMENTS,
    TEI_TRANSCR_ELEMENTS,
    TEI_GAIJI_ELEMENTS,
    TEI_VERSE_ELEMENTS,
    TEI_SPOKEN_ELEMENTS,
    TEI_FIGURES_ELEMENTS,
    TEI_AUTO_GENERATED_ELEMENTS,
  ];

  for (const arr of staticArrays) {
    for (const staticEl of arr) {
      const p5El = elementMap.get(staticEl.name);
      if (p5El) {
        // Merge: union of children from both sources to include all valid children
        // (length comparison was buggy - static may have elements P5 doesn't and vice versa)
        const mergedChildren = mergeArrays(staticEl.children, p5El.children);

        // Merge attributes: P5 class-resolved attrs + static local attrs
        const mergedAttrs = mergeAttributes(p5El.attributes ?? [], staticEl.attributes ?? []);

        elementMap.set(staticEl.name, {
          ...p5El,
          documentation: staticEl.documentation || p5El.documentation,
          children: mergedChildren,
          attributes: mergedAttrs,
        });
      }
    }
  }

  return Array.from(elementMap.values());
}

/**
 * Merge two string arrays into a union (deduplicated)
 * Used for children arrays to include elements from both static and P5 definitions
 */
function mergeArrays(a?: string[], b?: string[]): string[] | undefined {
  if (!a && !b) return undefined;
  if (!a) return b;
  if (!b) return a;
  return [...new Set([...a, ...b])];
}

/**
 * Merge two attribute arrays, preferring the first but adding unique from second
 */
function mergeAttributes(primary: AttrSpec[], secondary: AttrSpec[]): AttrSpec[] {
  const seen = new Set(primary.map(a => a.name));
  const result = [...primary];

  for (const attr of secondary) {
    if (!seen.has(attr.name)) {
      result.push(attr);
    }
  }

  return result;
}

/**
 * Get count of elements by module for diagnostics
 */
export function getElementCounts(): Record<string, number> {
  const p5Stats = getP5Stats();
  return {
    'P5 Elements': p5Stats.elements,
    'P5 Attribute Classes': p5Stats.attrClasses,
    'P5 Total Attrs': p5Stats.totalAttrs,
    '---': 0,
    'TEI Lite (static)': TEI_LITE_ELEMENTS.length,
    'TEI All Extra (static)': TEI_ALL_EXTRA_ELEMENTS.length,
    'MS Description (static)': TEI_MSDESC_ELEMENTS.length,
    'Header Extra (static)': TEI_HEADER_EXTRA_ELEMENTS.length,
    'Names & Dates (static)': TEI_NAMESDATES_ELEMENTS.length,
    'Text Criticism (static)': TEI_TEXTCRIT_ELEMENTS.length,
    'Linking (static)': TEI_LINKING_ELEMENTS.length,
    'Analysis (static)': TEI_ANALYSIS_ELEMENTS.length,
    'Transcription (static)': TEI_TRANSCR_ELEMENTS.length,
    'Gaiji (static)': TEI_GAIJI_ELEMENTS.length,
    'Verse (static)': TEI_VERSE_ELEMENTS.length,
    'Spoken (static)': TEI_SPOKEN_ELEMENTS.length,
    'Figures (static)': TEI_FIGURES_ELEMENTS.length,
    'Auto-generated': TEI_AUTO_GENERATED_ELEMENTS.length,
  };
}
