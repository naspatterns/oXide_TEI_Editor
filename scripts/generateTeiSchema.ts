#!/usr/bin/env npx tsx
/**
 * TEI Schema Generator
 *
 * This script parses official TEI RelaxNG schemas and generates TypeScript
 * element definitions for autocompletion in the oXide TEI Editor.
 *
 * Usage:
 *   npx tsx scripts/generateTeiSchema.ts [--download]
 *
 * Options:
 *   --download    Download fresh RNG from TEI-C website (requires network)
 *
 * Output:
 *   src/schema/teiAutoGenerated.ts
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = join(__dirname, '..');

// TEI RNG URLs (official sources)
const TEI_ALL_RNG_URL = 'https://tei-c.org/Vault/P5/current/xml/tei/custom/schema/relaxng/tei_all.rng';
const LOCAL_RNG_PATH = join(PROJECT_ROOT, 'tei_all.rng');
const OUTPUT_PATH = join(PROJECT_ROOT, 'src/schema/teiAutoGenerated.ts');

// Import existing elements to avoid duplicates
import { TEI_LITE_ELEMENTS, TEI_ALL_EXTRA_ELEMENTS } from '../src/schema/teiStaticSchema.js';

interface ParsedElement {
  name: string;
  documentation: string;
  children: string[];
  attributes: { name: string; documentation?: string; values?: string[] }[];
}

/**
 * Parse RelaxNG XML to extract element definitions
 * This is a simplified parser that handles the most common patterns
 */
function parseRngXml(rngXml: string): ParsedElement[] {
  const elements: ParsedElement[] = [];

  // Match <rng:define> or <define> blocks with element definitions
  // TEI RNG uses patterns like:
  // <define name="element.name">
  //   <element name="elementName">
  //     ...
  //   </element>
  // </define>

  // Simple regex-based extraction (works for TEI RNG structure)
  const defineRegex = /<(?:rng:)?define\s+name="([^"]+)"[^>]*>([\s\S]*?)<\/(?:rng:)?define>/g;
  const elementRegex = /<(?:rng:)?element\s+name="([^"]+)"[^>]*>/;
  const docRegex = /<(?:a:)?documentation[^>]*>([\s\S]*?)<\/(?:a:)?documentation>/;
  const refRegex = /<(?:rng:)?ref\s+name="([^"]+)"/g;
  const attributeRegex = /<(?:rng:)?attribute\s+name="([^"]+)"[^>]*>[\s\S]*?<\/(?:rng:)?attribute>/g;
  const valueRegex = /<(?:rng:)?value[^>]*>([^<]+)<\/(?:rng:)?value>/g;

  // Track element patterns for child relationship resolution
  const patternToElement = new Map<string, string>();
  const elementPatterns = new Map<string, Set<string>>();

  let match;

  // First pass: identify element definitions and their patterns
  while ((match = defineRegex.exec(rngXml)) !== null) {
    const defineName = match[1];
    const defineContent = match[2];

    const elementMatch = elementRegex.exec(defineContent);
    if (elementMatch) {
      patternToElement.set(defineName, elementMatch[1]);
    }
  }

  // Reset regex
  defineRegex.lastIndex = 0;

  // Second pass: extract elements with their properties
  while ((match = defineRegex.exec(rngXml)) !== null) {
    const defineName = match[1];
    const defineContent = match[2];

    const elementMatch = elementRegex.exec(defineContent);
    if (!elementMatch) continue;

    const elementName = elementMatch[1];

    // Skip if already defined manually
    const existingNames = new Set([
      ...TEI_LITE_ELEMENTS.map((e) => e.name),
      ...TEI_ALL_EXTRA_ELEMENTS.map((e) => e.name),
    ]);
    if (existingNames.has(elementName)) continue;

    // Extract documentation
    const docMatch = docRegex.exec(defineContent);
    const documentation = docMatch
      ? docMatch[1].trim().replace(/\s+/g, ' ').substring(0, 200)
      : '';

    // Extract child element references
    const children: string[] = [];
    let refMatch;
    while ((refMatch = refRegex.exec(defineContent)) !== null) {
      const refName = refMatch[1];
      // Resolve pattern to element name
      const childElement = patternToElement.get(refName);
      if (childElement && !children.includes(childElement)) {
        children.push(childElement);
      }
    }

    // Extract attributes
    const attributes: { name: string; documentation?: string; values?: string[] }[] = [];
    let attrMatch;
    while ((attrMatch = attributeRegex.exec(defineContent)) !== null) {
      const attrName = attrMatch[1];
      const attrContent = attrMatch[0];

      // Extract attribute values if enumerated
      const values: string[] = [];
      let valMatch;
      const valueRegexLocal = /<(?:rng:)?value[^>]*>([^<]+)<\/(?:rng:)?value>/g;
      while ((valMatch = valueRegexLocal.exec(attrContent)) !== null) {
        values.push(valMatch[1].trim());
      }

      attributes.push({
        name: attrName,
        ...(values.length > 0 && { values }),
      });
    }

    elements.push({
      name: elementName,
      documentation,
      children,
      attributes,
    });
  }

  return elements;
}

/**
 * Generate TypeScript code for the parsed elements
 */
function generateTypeScript(elements: ParsedElement[]): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated TEI element definitions',
    ' * Generated from official TEI RelaxNG schema',
    ' *',
    ` * Generated: ${new Date().toISOString()}`,
    ` * Elements: ${elements.length}`,
    ' *',
    ' * DO NOT EDIT MANUALLY - regenerate with: npm run generate-schema',
    ' */',
    '',
    "import type { ElementSpec, AttrSpec } from '../types/schema';",
    '',
    '// Global attributes applied to all elements',
    'const globalAttrs: AttrSpec[] = [',
    "  { name: 'xml:id', documentation: 'Unique identifier' },",
    "  { name: 'xml:lang', documentation: 'Language code' },",
    "  { name: 'n', documentation: 'Number or label' },",
    "  { name: 'type', documentation: 'Type classification' },",
    "  { name: 'rend', documentation: 'Rendition' },",
    "  { name: 'resp', documentation: 'Responsible party' },",
    "  { name: 'cert', documentation: 'Certainty level' },",
    "  { name: 'corresp', documentation: 'Corresponds to' },",
    '];',
    '',
    'function el(',
    '  name: string,',
    '  doc: string,',
    '  children: string[],',
    '  extraAttrs: AttrSpec[] = [],',
    '): ElementSpec {',
    '  return {',
    '    name,',
    '    documentation: doc,',
    '    children,',
    '    attributes: [...globalAttrs, ...extraAttrs],',
    '  };',
    '}',
    '',
    '/** Auto-generated TEI elements from RNG */',
    'export const TEI_AUTO_GENERATED_ELEMENTS: ElementSpec[] = [',
  ];

  for (const el of elements) {
    const childrenStr = el.children.length > 0
      ? `[${el.children.map((c) => `'${c}'`).join(', ')}]`
      : '[]';

    const attrsStr = el.attributes.length > 0
      ? `, [\n    ${el.attributes.map((a) => {
          const valuesStr = a.values ? `, values: [${a.values.map((v) => `'${v}'`).join(', ')}]` : '';
          const docStr = a.documentation ? `, documentation: '${a.documentation}'` : '';
          return `{ name: '${a.name}'${valuesStr}${docStr} }`;
        }).join(',\n    ')}\n  ]`
      : '';

    const docEscaped = el.documentation.replace(/'/g, "\\'").replace(/\n/g, ' ');

    lines.push(`  el('${el.name}', '${docEscaped}', ${childrenStr}${attrsStr}),`);
  }

  lines.push('];');
  lines.push('');

  return lines.join('\n');
}

/**
 * Download TEI RNG from official source
 */
async function downloadRng(): Promise<string> {
  console.log(`Downloading TEI All RNG from ${TEI_ALL_RNG_URL}...`);

  const response = await fetch(TEI_ALL_RNG_URL);
  if (!response.ok) {
    throw new Error(`Failed to download RNG: ${response.status} ${response.statusText}`);
  }

  const rngXml = await response.text();
  console.log(`Downloaded ${(rngXml.length / 1024 / 1024).toFixed(2)} MB`);

  // Save locally for future use
  writeFileSync(LOCAL_RNG_PATH, rngXml, 'utf-8');
  console.log(`Saved to ${LOCAL_RNG_PATH}`);

  return rngXml;
}

/**
 * Main entry point
 */
async function main() {
  const args = process.argv.slice(2);
  const shouldDownload = args.includes('--download');

  console.log('=== TEI Schema Generator ===\n');

  let rngXml: string;

  if (shouldDownload || !existsSync(LOCAL_RNG_PATH)) {
    try {
      rngXml = await downloadRng();
    } catch (err) {
      console.error('Failed to download RNG:', err);
      console.log('\nFalling back to minimal auto-generation...');
      // Generate empty file if download fails
      const emptyOutput = `/**
 * Auto-generated TEI element definitions
 * Generated: ${new Date().toISOString()}
 *
 * Note: RNG download failed, no auto-generated elements
 * Run \`npm run generate-schema -- --download\` when network is available
 */

import type { ElementSpec } from '../types/schema';

export const TEI_AUTO_GENERATED_ELEMENTS: ElementSpec[] = [];
`;
      writeFileSync(OUTPUT_PATH, emptyOutput, 'utf-8');
      console.log(`\nGenerated empty ${OUTPUT_PATH}`);
      return;
    }
  } else {
    console.log(`Reading local RNG from ${LOCAL_RNG_PATH}...`);
    rngXml = readFileSync(LOCAL_RNG_PATH, 'utf-8');
    console.log(`Read ${(rngXml.length / 1024 / 1024).toFixed(2)} MB`);
  }

  // Parse RNG
  console.log('\nParsing RNG...');
  const elements = parseRngXml(rngXml);
  console.log(`Extracted ${elements.length} new elements`);

  // Report existing element counts
  const existingCount = TEI_LITE_ELEMENTS.length + TEI_ALL_EXTRA_ELEMENTS.length;
  console.log(`\nManual elements: ${existingCount}`);
  console.log(`Auto elements: ${elements.length}`);
  console.log(`Total unique: ${existingCount + elements.length}`);

  // Generate TypeScript
  console.log('\nGenerating TypeScript...');
  const tsCode = generateTypeScript(elements);

  // Write output
  writeFileSync(OUTPUT_PATH, tsCode, 'utf-8');
  console.log(`\nGenerated ${OUTPUT_PATH}`);
  console.log(`File size: ${(tsCode.length / 1024).toFixed(2)} KB`);
}

main().catch((err) => {
  console.error('Error:', err);
  process.exit(1);
});
